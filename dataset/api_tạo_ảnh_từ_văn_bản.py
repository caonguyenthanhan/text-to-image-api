# -*- coding: utf-8 -*-
"""API tạo ảnh từ văn bản.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1peQzjWWjerE4n2nwbB7Ngyq9fVvgcogI
"""

from google.colab import drive
drive.mount('/content/drive')

# !pip install torch torchvision torchaudio
# !pip install yolov5

import torch

model = torch.hub.load('ultralytics/yolov5', 'yolov5s')  # Hoặc yolov5m, yolov5l, yolov5x



# Đường dẫn đến tập dữ liệu
dataset_path = "/content/drive/MyDrive/txttoimage11/dataset"

import os

def analyze_images(dataset_path, model):
    """
    Phân tích ảnh trong tập dữ liệu và tạo nhãn.

    Args:
      dataset_path: Đường dẫn đến thư mục chứa tập dữ liệu.
      model: Mô hình YOLOv5.
    """
    for filename in os.listdir(dataset_path):
        if filename.endswith(('.jpg', '.jpeg', '.png')):
            image_path = os.path.join(dataset_path, filename)
            results = model(image_path)

            # Trích xuất đặc điểm đối tượng
            labels = []
            for *xyxy, conf, cls in results.xyxy[0]:
                label = model.names[int(cls)]
                labels.append(label)

            # Lưu nhãn vào file txt cùng tên với ảnh
            label_path = os.path.splitext(image_path)[0] + ".txt"
            with open(label_path, "w") as f:
                f.write(", ".join(labels))

# Gọi hàm phân tích ảnh
analyze_images(dataset_path, model)

# !pip install datasets -q

from torchvision import transforms

def preprocess(image):
    preprocess = transforms.Compose(
        [
            transforms.Resize((512, 512)),
            transforms.ToTensor(),
            transforms.Normalize([0.5], [0.5]),
            transforms.ToPILImage(),  # Chuyển đổi thành ảnh PIL
        ]
    )
    return preprocess(image)

import torch
from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
from datasets import load_dataset
from transformers import TrainingArguments, Trainer

# Tải tập dữ liệu
dataset = load_dataset("imagefolder", data_dir=dataset_path)

# Khởi tạo pipeline Stable Diffusion
pipe = StableDiffusionPipeline.from_pretrained("stabilityai/stable-diffusion-2", torch_dtype=torch.float16)
pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
pipe = pipe.to("cuda")

# Xử lý tập dữ liệu (bao gồm đọc nhãn từ file txt)
def preprocess_function(examples):
    images = [preprocess(image.convert("RGB")) for image in examples["image"]]
    examples["pixel_values"] = pipe.feature_extractor(images=images, return_tensors="pt").pixel_values

    # Lấy danh sách các file ảnh trong dataset
    image_filenames = dataset["train"].cache_files

    # Đọc nhãn từ file txt
    labels = []
    for i, image in enumerate(examples["image"]):
        # Trích xuất tên file ảnh
        image_filename = os.path.basename(image_filenames[i]["filename"])
        label_path = os.path.join(dataset_path, os.path.splitext(image_filename)[0] + ".txt")
        with open(label_path, "r") as f:
            labels.append(f.read())

    examples["labels"] = labels
    return examples

dataset = dataset.map(preprocess_function, batched=True)

# Tham số huấn luyện
training_args = TrainingArguments(
    output_dir="path/to/save/model",
    per_device_train_batch_size=4,
    per_device_eval_batch_size=4,
    learning_rate=5e-6,
    num_train_epochs=10,
    save_strategy="epoch",
    push_to_hub=False,
)

# Huấn luyện mô hình
trainer = Trainer(
    model=pipe,
    args=training_args,
    train_dataset=dataset["train"],
)

trainer.train()

# Lưu mô hình
pipe.save_pretrained("path/to/save/model")

from flask import Flask, request, jsonify
from diffusers import StableDiffusionPipeline

app = Flask(__name__)

# Tải mô hình Stable Diffusion đã huấn luyện
pipe = StableDiffusionPipeline.from_pretrained("path/to/save/model")
pipe = pipe.to("cuda")

@app.route('/generate', methods=['POST'])
def generate():
    description = request.form['description']
    # Xử lý mô tả và tạo prompt (ví dụ: thêm "no background")
    prompt = f"{description}, no background"
    image = pipe(prompt).images[0]
    # Chuyển đổi image sang base64 hoặc lưu vào file
    # ...
    return jsonify({'image': image_base64})  # Trả về ảnh

if __name__ == '__main__':
    app.run()